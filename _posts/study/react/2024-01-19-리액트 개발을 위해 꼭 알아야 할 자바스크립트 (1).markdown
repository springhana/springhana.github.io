---
layout: post
related_posts:
  - /study/react
title: 리액트 개발을 위해 꼭 알아야 할 자바스크립트 (1)
categories:
  - study
  - react
image: /assets/img/react/modern-react-book.png
permalink: '/:categories/:year/:month/:day/:title/'
description: >
  모던 리액트 Deep Dive: 리액트의 핵심 개념과 동작 원리부터 Next.js까지, 리액트의 모든 것 - 01장 리액트 개발을 위해 꼭 알아야 할 자바스크립트
---

* toc
{:toc}

본격적으로 리액트 다루기에 앞서, 리액트 코드의 기반이 되는 자바스크립트에 대해 먼저 알아보고자 한다.

# 자바스크립트의 동등 비교

리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자비스크립트의 동등 비교를 기반으로 한다. 자바스크립트의 이러한 동등 비교는 어떻게 수행되는지, 이를 리액트에서 어떻게 활용하고 있는지 살펴보자.

<br>

## **자바스크립트의 데이터 타입**

자바스크립트의 모든 값은 데이터 타입을 갖고 있으며, 이 데이터 타입은 크게 원시 타입과 객체 타입으로 나눌 수 있다.

**🛠️ 참고**

<ul class="related-posts">
  <li class="h6">
    <div>
      <a href="https://springhana.github.io/study/javascript/2024/02/11/%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90/" class="flip-title">
        <span>원시 값과 객체의 비교</span>
      </a>
    </div>
  </li>
   <li class="h6">
    <div>
      <a href="https://springhana.github.io/study/javascript/2024/02/01/%EC%97%B0%EC%82%B0%EC%9E%90/" class="flip-title">
        <span>원시 값과 객체의 비교</span>
      </a>
    </div>
  </li>
</ul>

<br>

<strong style="color:skyblue">원시 타입(primitive type)</strong>

- boolean
- null
- undefined
- number
- string
- symbol
- bigint

<strong style="color:skyblue">원시 타입(primitive type)</strong>

- object

<br>

<strong class="p_">원시 타입</strong>

자바스크립트에서 원시 타입이란 간단히 정의하자면 객체가 아닌 다른 모든 타입을 의미한다. 객체가 아니므로 이러한 타입들은 메서드를 갖지 않는다. ES2022와 같은 최신 자바스크립트에서는 총 7개의 원시 타입이 있다.

<strong class="purple_">undefined</strong>

undefined는 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지짖 않은 인수에 자동으로 할당되는 값이다.

```jsx
let foo

type foo === 'undefined' // true

function bar(hello) {
  return hello
}

typeof bar() === 'undefined' // true
```

후술한 원시값 중 null과 undefined는 오직 각각 null과 undefined라는 값만 가질 수 있으며, 그 밖의 타입을 가질 수 있는 값이 두 개 이상(boolean의 true, false와 같이)
존재한다.

<br>

<strong class="purple_">null</strong>

아직 값이 없거나 비어 있는 값을 표현할 때 사용한다.

```js
typeof null === 'object' // true?
```

null이 가지고 있는 특별한 점 하나는 다른 원시값과 다르게 typeof로 null을 확인했을 때 해당 타입이 아닌 'object'라는 결과가 반환된다는 것이다.

**undefined는 '선언됐지만 할당되지 않은 값' 이고, null은 '명시적으로 비어 있음을 나타내는 값'으로 사용하는 것이 일반적이다.**

<br>

<strong class="purple_">Boolean</strong>

참(true)과 거짓(false)만을 가질 수 잇는 데이터 타입이다.

한 가지 주목할 만한 점은 true, false와 같은 boolean 형의 값 외에도 조건문에서 마치 true와 false처럼 취급되는 truthy, falsy 값이 존재한다는 것이다.

- falsy: 조건문 내부에서 flase로 취급되는 값을 말한다.

  |값|타입|설명|
  |:---|:---|:---|
  |false|Boolean|false는 대표적인 falsy한 값이다.|
  |0, -0, 0n, 0x0n|Number, BigInt|0은 부호나 소수점 유무에 상관없이 falsy한 값이다.|
  |NaN|Number|Number가 아니라는 것을 뜻하는 NaN(Not a Number)은 falsy한 값이다.|
  |'', "", ``|String|문자열이 falsy하기 위해서는 반드시 공백이 없는 빈 문자열이어야 한다.|
  |null|null|null이 falsy한 값이다.|
  |undefined|undefined|undefined는 falsy한 값이다.|

- truthy: 조건문 내부에서 true로 취급되는 값, 앞아서 언급한 falsy로 취급되는 값 이외에는 모두 true로 취급된다.

  한 가지 유념할 점은 객체와 배열에 값이 존재하는지 여부와 상관없이 truthy로 취급된다는 것이다. 즉, {}, [] 모두 truthy한 값이다.

  ```js
  if (1) {
    // true
  }

  if (0) {
    // false
  }

  if (NaN) {
    // false
  }

  // 조건문 외에도 truthy와 falsy를 Boolean()을 통해 확인할 수도 있다.
  Boolean(1) // true
  Boolean(2) // false
  Boolean(true) // true
  ```

<br>

<strong class="purple_">Number</strong>

정수와 실수를 구분해 저장하는 다른 언어와 다르게, 자바스크립트는 모두 숫자를 하나의 타입에 저장했었다. ESMAScript 표준에 따르면 -(2^53-1)과 2^53-1 사이의 값을 저장할 수 있다.

```js
const a = 1;

const maxInteger = Math.pow(2, 53);
maxInteger - 1 === Number.MAX_SAFE_INTEGER // true

const minInteger = -(Math.pow(2, 53) - 1);
minInteger === Number.MIN_SAFE_INTEGER // true
```

또한 2진수, 8진수, 16진수 등의 빌드 데이터 타입을 제공하지 않으므로 각 진수별로 값을 표현해도 모두 10진수로 해석되어 동일한 값으로 표시된다.

```js
const 이진수_2 = 0b10; // 2진수(binary) 2
이진수_2 === (2).toString(2); // true(2)를 괄호로 선언한 이유는 .2뒤에 점이 있으면 소수점으로 인식하기 때문

const 팔진수_8 = 0o10; // 8진수 (octal) 8
팔진수_8 === (8).toString(8) // true

10 === (10).toString(10); // true

const 십육진수_16 = 0x10 // 16진수 (hexadecimal) 16
십육진수_16 == (16).toString(16) // true
```

<br>

<strong class="purple_">Bigint</strong>

앞서 number가 다를 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나온 것으로, 최대 2^53 - 1을 저장할 수 있는 number의 한계를 넘어서 더 큰 숫자를 저장할 수 있게 해준다.

```js
// 기존 number의 한계
9007199254740992 === 9007199254740993 // 마지막 숫자는 다른데 true가 나온다. 이는 더 이상 다룰 수 없는 크기이기 때문이다.

const maxInteger = Number.MAX_SAFE_INTEGER;
console.log(maxInteger + 5 === maxInteger + 6) // true??
const bigInt1 = 9007199254740995n // 끝에 n을 붙이거나
const bigInt2 = BigInt('9007199254740995') // BigInt 함수를 사용하면 된다.

const number = 9007199254740992;
const bigint = 9007199254740992n;

typeof number; // number
typeof bigint; // bigint

number == bigint;  // true
number === bigint; // false (타입이 달라서 false가 반환된다.)
```

<br>

<strong class="purple_">String</strong>

string은 텍스트 타입의 데이터를 저장하기 위해 사용된다. 한 쌍의 작음따옴표 `'` 나 큰따옴표 `"`. 또는 내장 표현식을 허용하는 문자열 리터럴 표현 방식인 백틱 ` ` ` 으로도 표현할 수 있다.

백틱을 사용해서 표현한 문자열을 템플릿 리터럴(template literal)이라고 하는데, 같은 문자열을 반환하지만 줄바꿈이 가능하고, 문자열 내부에 표현식을 쓸 수 있다는 차이가 있다.

```js
// '\n안녕하세요.\n'
const longText = `
안녕하세요.
`

//Uncaught SyntaxError: Invalid or unexpected token
const longText = "
안녕하세요.
"
```

자바스크립트는 문자열의 특징 중 하나는 문자열이 원시 타입이며 변경 불가능하다는 것이다. 이것은 한번 문자열이 생성되면 그 문자열을 변경할 수 없음을 의미한다.

```js
const foo = 'bar'

console.log(foo[0]) // 'b'

// 앞 글자를 다른 글자로 변경해 보았다.
foo[0] = 'a'

// 이는 반영되지 않는다.
console.log(foo) // bar
```

<br>

<strong class="purple_">Symbol</strong>

Symbol은 ES6에서 새롭게 추가된 7번째 타입으로, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다. 

심벌은 함수를 이용해서만 만들 수 있다. 즉, 심벌을 생성하려면 반드시 Symbol()을 사용해야만 한다.

```js
// Symbol 함수에 같은 인수를 넘겨주더라도 이는 동일한 값으로 인정되지 않는다.
// 심벌 함수 내부에 넘겨주는 값을 Symbol 생성에 영향을 미치지 않는다 (Symbol.for 제외)
const key = Symbol('key');
const key2 = Symbol('key')

key === key2 // false

// 동일한 값을 사용하기 위해서는 Symbol.for을 활용한다.
Symbol.for('hello') === Symbol.for('hello') // true
```

<br>

<strong class="p_">객체 타입</strong>

객체 타입을 간단하게 정의하면 앞서 7가지 원시 타입 이외의 모든 것, 즉 자바스크립트를 이루고 있는 대부분의 타입이 바로 객체 타입이다. 여기에는 배열, 함수, 정규식, 클래스 등이 포함된다.

여기서 한 가지 주목할 것이 객체 타입(object type)은 참조를 전달한다고 해서 참조 타입(reference type)으로도 불린다는 사실이다.

```js
typeof [] === 'object' // true
typeof {} === 'object' // true

function hello() {}

typeof hello === 'function' // true

const hello1 = function() {
}

const hello2 = function() {
}

// 객체인 함수의 내용이 육안으로는 같아 보여도 참조가 다르기 때무에 false가 반환된다.

hello1 === hello2 // false
```

<br>

## **값을 저장하는 방식의 차이**

원시 타입과 객체 타입의 가장 큰 차이점으라고 한다면. 바로 값을 저장하는 방식의 차이다. 이 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원이이 된다.

- 먼저 원시 타입은 불편 형태의 값으로 저장된다. 그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장한다.

  ```js
  let hello = 'hello world'
  let hi = hello

  console.log(hello === hi) // true
  ```

  당연히 이 두 값을 비교하면 true가 나온다. 이는 hello의 hello world라는 값이 hi에 복사해 전달됐기 때문이다. 값을 비교하기 때문에, 값을 전달하는 방식이 아닌 각각 선언하는 방식으로도 동일한 결과를 볼 수 있다.

  ```js
    let hello = 'hello world'
  let hi = 'hello world'

  console.log(hello === hi) // true
  ```
  
반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다. 다음 예제 코드를 살펴보자.

```js
// 다음 객체는 완벽하게 동일한 내용을 가지고 있다.
var hello = {
  greet: 'hello, world',
}

var hi = {
  greet: 'hello, world',
}

// 그러나 동등 비교를 하면 false가 나온다.
console.log(hello === hi) // false

// 원시값이 내부 속성값을 비교하면 동일하다.
console.log(hello.greet === hi.greet) // true
```

객체는 값을 저장하는게 아니라 참조를 저장하기 때문에 앞서 동일하게 선언했던 객체라 하더라도 저장하는 순산 다른 참조를 바라보기 때문에 false를 반환하게 된다.

즉, 값은 같았을지언정 참조하는 곳이 다른 셈이다. 반면 참조를 전달하는 경우에는 이전에 원시값에서 했던 것과 같은 결과를 기대할 수 있다.

- hello와 hi 변수는 변수명 및 각 변수명의 주소가 서로 다르지만 **value가 가리키는 주소가 동일하다.**

  ```js
  var hello = {
    greet: 'hello, world',
  }

  var hi = hello

  console.log(hi === hello) // true
  ```

<br>

자바스크립트 개발자는 항상 객체 간에 비교가 발생하면, 이 객체 간의 비교는 우리가 이해하는 내부의 값이 같다하더라도 결과는 대부분 true가 아닐 수 있다는 것을 인지해야 한다.

<br>

## **자바스크립트의 또 다른 비교 공식, Object.is**

자바스크립트에서는 비교를 위한 또 한 가지 방법을 제공하는데, 바로 Object.is다, Object.is는 두 개인 인수를 받으며, 이 인수 두개가 동일한지 확인하고 반환하는 메서드다.

- `==` vs `Object.is` : `==` 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환(type casting)을 한 후에 변경한다. 하지만 Object.is는 이러한 작업을 하지 않고 ===와 동일하게 타입이 다르면 그냥 false다.

- `===` vs `Object.is` : 이 방법에도 차이가 있다. `Object.is` 가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다.

  ```js
  -0 === +0; // true
  Object.is(-0, +0) // false

  Number.NaN === NaN; // false
  Objectis(Number.NaN, NaN) // true

  NaN === 0 / 0 // false
  Object.is(NaN, 0 / 0) // true
  ```

주의 할 점은, `Object.is`를 사용한다 하더라도 객체 비교에는 별 차이가 없다는 것이다.

```js
Object.is({}, {}) // false

const a = {
  hello: 'hi,
}

const b = a;

Object.is(a, b); // true
a === b // true
```

`Object.is`는 Es6(ECMAScript 2015)에서 새롭게 도입된 비교 문법으로, 위와 같이 몇 가지 특별한 사항에서 동등 비교 `===`가 가지는 한계를 극복하기 위해 만들어졌다. 

그러나 여전히 객체 간 비교에 있어서는 자바스크립트의 특징으로 인해 `===`와 동일하게 동작하는 것을 알 수 있다.

<br>

## **리액트에서의 동등 비교**

리액트에서 사용하는 동등 비교는 `==`나 `===`가 아닌 이 `Object.is`다. `Object.is`는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(Polyfill)을 할께 사용한다.

```js
// flow로 구현돼 있어 any가 추가돼 있다. 
//flow에서 any는 타입스크립트와 동일하게 어떠한 값도 받을 수 있는 타입을 의미한다.

function is(x: any, y: any) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
  )
}

// 런타임에 Object.is가 있다면 그것을 사용하고, 아니라면 위 함수를 사용한다.
// Object.is는 인터넷 익스플로러 등에 존재하지 않기 때문에 폴리필을 넣어준 것으로 보인다.
const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === 'function' ? Object.is : is;

export default objectIs;
```
© https://github.com/facebook/react/blob/main/packages/shared/objectIs.js

<br>

리액트에서는 이 ObjectIs를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어 사용한다. 이 shallowEqual은 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용된다.

```js
import is from './objectIs';
// 다음 코드는 Object.prototype.hasOwnProperty다.
// 이는 객체에 특정 프로퍼티가 있는지 확인하는 메서드다.
import hasOwnProperty from './hasOwnProperty';

/**
 * 주어진 객체의 키를 순회하면서 두 값이 엄격한 동등성을 자니는지를 확인하고,
 * 다른 값이 있다면 false를 반환한다. 만약 두 객체 간에 모두 키와 값이 동일하다면
 * true를 반환한다.
 * */

// 단순히 Object.is를 수행하는 것뿐만 아니라 객체 간의 비교도 추가돼 있다.
function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  // 각 키 배열을 꺼낸다.
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  // 배열의 길이가 다르다면 false
  if (keysA.length !== keysB.length) {
    return false;
  }

  // A의 키를 기준으로, B에 같은 키가 있는지, 그리고 그 값이 같은지 확인한다. 
  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}

export default shallowEqual;
```
© https://github.com/facebook/react/blob/main/packages/shared/shallowEqual.js

<br>

리액트에서의 비교를 요약하자면 `Object.is`로 먼저 비교를 수행한 다음에 `Object.is`에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행하는 것을 알 수 있다.

객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

```js
// Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
Object.is({hello: 'world'}, {hello: 'world'}) // false

// 반면 리액트 팀에서 구현한 shallowEqual은  객체의 1 depth까지는 비교가 가능하다.
shallowEqual({hello: 'world'}, {hello: 'world'}) // true

// 그러나 2 depth까지 가면 이를 비교할 방법이 없으므로 false를 반환한다.
shallowEqual({hello: {hi: 'world'}}, {hello: {hi: 'world'}}) // false
```

이렇게 객체의 얕은 비교까지만 구현한 이유는 리액트에서 사용하는 JSX props는 객체이고, 그리고 여기에 있는 props만 일차적으로 비교하면 되기 때문이다.

```ts
type Props = {
  hello: string
}
function HelloComponent(props:Props) {
  return <h1>{hello}</h1>
}
// ...

function App() {
  return <HelloComponent hello="hi!" />
}
```

위 코드에서 props는 객체다. 그리고 기본적으로 **리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분할 것이다.** 이러한 특성을 안다면 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

```jsx

```