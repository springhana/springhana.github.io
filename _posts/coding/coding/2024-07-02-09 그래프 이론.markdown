---
layout: post
related_posts:
  - _posts/coding/coding/2024-07-02-08 최단 경로 설명.markdown
title: 09 그래프 이론 (설명)
categories:
  - coding
  - coding
image: /assets/img/coding/이것이 코딩테스트다. 파이썬.png
permalink: '/:categories/:year/:month/:day/:title/'
description: >

 이것이 코딩 테스트다. with 파이썬 - 09 그래프 이론
---

* toc
{:toc}

> [(이코테 2021 강의 몰아보기) 9. 그래프 이론](https://www.youtube.com/watch?v=aOhhNFTIeFI&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=8)

# **⭐ 나동빈님의 유튜브를 통해 확인해 주세요!!**

---

![[이것이 코딩테스트다. 파이썬.png]]

# 그래프 이론

그래프(Graph란 노드(Node)와 노드사이에 연결된 간선(Edge)의 정보를 가지고 있는 자료구조를 의미한다.

- 알고리즘 문제를 접했을 때 ‘서로 다른 개체(혹은 객체)가 연결되어 있다’는 이야기를 들으면 가장 먼저 그래프 알고르짐을 떠올려야 한다.

---

# 서로소 집합

서로소 집합(Disjoint Sets)란 공통 원소가 없는 두 집합을 의미한다.

서로소 집합 자료구조를 설명하려면 서로소 집합 개념이 필요하다.

서로소 집합 자료구조란 **서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조**라고 할 수 있다.

서로소 집합 자료구조는 `union` 과 `find` 이 2개의 연산으로 조작할 수 있다.

- `union`(합집합) 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
- `find`(찾기) 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.

서로소 집합 자료구조는 `union-find` 자료구조라고 불리기도 한다. 연산의 이름 자체가 합치기와 찾기이기도 하고, 두 집합이 서로소 관계인지를 확인할 수 있다는 말은 각 집합이 어떤 원소를 공통으로 가지고 있는지를 확인할 수 있다는 말과 같기 때문이다.

## 서로소 집합 자료구조

여러 개의 합치기 연산이 주어졌을 때 서로소 집합 자료구조의 동작 과정은 다음과 같습니다.

1. 합집합(Union) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인합니다.
    
    1. A와 B의 루트 노드 A’, B’를 각각 찾습니다.
        
    2. A’를 B’의 부모 노드로 설정합니다.
        
2. 모든 합집합(Union) 연산을 처리할 때까지 1번의 과정을 반복합니다.
    

> 💡 트리 구조상 번호가 작은 노드가 부모가 되고, 번호가 큰 노드가 자식이 된다.

예제를 통해 서로소 집합 알고리즘을 자세히 확인해보겠다. `union` 연산을 하나씩 확인하면서 서로 다른 두 원소에 대해 합집합을 수행해야 할 때는, **각각 루투 노드를 찾아서 더 큰 루트 노드가 더 작은 루트 노드를 가리키도록 하면 된다.**

- 처리할 연산들: Union(1, 4), Union(2, 3), Union(2, 4), Union(5, 6)
- [초기 단계] 노드의 개수 크기의 부모 테이블을 초기화합니다.

- 처리할 연산들: `Union(1, 4)`, Union(2, 3), Union(2, 4), Union(5, 6)
- [Step 1] 노드 1과 노드 4의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 1과 4이므로 더 큰 번호에 해당하는 로트 노드 4의 부모를 1로 설정합니다.

- 처리할 연산들: Union(1, 4), `Union(2, 3)`, Union(2, 4), Union(5, 6)
- [Step 2] 노드 2과 노드 3의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 2와 3이므로 더 큰 번호에 해당하는 루트 노드 3의 부모를 2로 설정합니다.

- 처리할 연산들: Union(1, 4), Union(2, 3), `Union(2, 4)`, Union(5, 6)
- [Step 3] 노드 2과 노드 4의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 2와 1이므로 더 큰 번호에 해당하는 루트 노드 2의 부모를 1로 설정합니다.

- 처리할 연산들: Union(1, 4), Union(2, 3), Union(2, 4), `Union(5, 6)`
- [Step 4] 노드 5과 노드 6의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 5와 6이므로 더 큰 번호에 해당하는 6의 부모를 5로 설정합니다.

- 서로소 집합 자료구조에서는 **연결성을 통해 손쉽게 집합의 형태를 확인할 수 있습니다.**

기본적인 형태의 서로소 집합 자료구조에서는 루트 노드에 즉시 접근할 수 없습니다.

- 루트 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야 합니다,

다음 예시에서는 노드 3의 로투를 찾기 위해서는 노드2를 거쳐 노드 1에 접근해야 합니다.

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

# 두 원소가 속합 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1)  # 부모 테이블 초기화하기

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# Union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력하기
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

# 부모 테이블 내용 추가하기
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
```

```python
# 입력
6 4
1 4
2 3
2 4
5 6

# 출력
각 원소가 속한 집합: 1 1 1 1 5 5 
부모 테이블: 1 1 2 1 5 5 
```

## 서로소 집합 자료구조: 기본적인 구현 방법의 문제점

- 합집합(Union) 연산이 편향되게 이루어지는 경우 찾기(Find) 함수가 비효율적으로 동작합니다.
- 최악의 경우에는 찾기(Find) 함수가 모든 노드를 다 확인하게 되어 시간 복잡도가 O(V)입니다.
    - 다음과 같이 {1, 2, 3, 4, 5}의 총 5개의 원소가 존재하는 상황을 확인해 봅시다.
    - 수행된 연산들: Union(4, 5), Union(3, 4), Union(2, 3), Union(1, 2)


## 서로소 집합 자료구조: 경로 압축

- 찾기(Find) 함수를 최적화하기 위한 방법으로 경로 압축(Path Compression)을 이용할 수 있습니다.
    
    - 찾기(Find) 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 바로 갱신합니다.
    
    ```python
    # 특정 원소가 속한 집합을 찾기
    def find_parent(parent, x):
    	# 루트 노드가 아니라먄, 루트 노드를 찾을 때까지 재귀적으로 호출
    	if parent[x] != x:
    		parent[x] = find_parent(parent, parent[x])
    	return parent[x]
    ```
    
    - 경로 압축 기법을 적용하면 각 노드에 대하야 찾기(Find) 함수를 호출한 이후에 해당 노드의 루트 노드가 바로 부모 노드가 됩니다.
    - 동일한 예시에 대해서 **모든 합집합(Union) 함수를 처리한 후 각 원소에 대하여 찾기(Find) 함수를 수행하면 다음과 같이 부모 테이블이 갱신**됩니다.
    - 기본적인 방법에 비하여 시간 복잡도가 개선됩니다.


```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀 호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1)  # 부모 테이블 초기화하기

# 부모 테이블상에서 부모를 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# Union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력하기
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

# 부모 테이블 내용 출력하기
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
```

```python
# 출력
6 4
1 4
2 3
2 4
5 6

# 결과
각 원소가 속한 집합: 1 1 1 1 5 5 
부모 테이블: 1 1 1 1 5 5 
```

## 서로소 집합을 활용한 사이클 판별

- 서로서 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있습니다.
    - 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있습니다.
- 사이클 판별 알고리즘은 다음과 같습니다.

1. 각 간선을 하나씩 확인하며 두 노드의 루트 노드를 확인합니다.
    1. 루트 노드가 서로 다르다면 두 노드에 대하여 합집합(Union) 연산을 수행합니다.
    2. 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것입니다.
2. 그래프 포함되어 있는 모든 간선에 대하여 1번 과정을 반복합니다.

- [초기 단계] 모든 노드에 대하여 자기 자신을 부모로 설정하는 형태로 부모 테이블을 초기화합니다.

- [Step 1] 간선 (1, 2)를 확인합니다. 노드 1과 노드 2의 루트 노드는 각각 1과 2입니다. 따라서 더 큰 번호에 해당하는 노드 2의 부모 노드를 1로 변경합니다.

- [Step 2] 간선 (1, 3)을 확인합니다. 노드 1과 노드 3의 루트 노드는 각각 1과 3입니다. 따라서 더 큰 번호에 해당하는 노드 3의 부모 노드를 1로 변경합니다.

- [Step 3] 간선 (2, 3)을 확인합니다. 이미 노드 2과 노드 3의 루트 노드는 모두 1입니다. 다시 말해 **사이클이 발생한다는 것을 알 수 있습니다.**

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀 호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1)  # 부모 테이블 초기화하기

# 부모 테이블 상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

cycle = False  # 사이클 발생 여부

for i in range(e):
    a, b = map(int, input().split())
    # 사이클이 발생한 경우 종료
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        break
    # 사이클이 발생하지 않았다면 합집합(Union) 연산 수행
    else:
        union_parent(parent, a, b)

if cycle:
    print('사이클이 발생했습니다.')
else:
    print('사이클이 발생하지 않았습니다.')
```

```python
# 출력
3 3
1 2
1 3
2 3

# 결과
사이클이 발생했습니다.
```

# 신장 트리

그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미합니다.

- 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 조건이기도 합니다.

## 최소 신장 트리

최소한의 비용으로 구성되는 트리를 찾아야 할 때 어떻게 해야 할까요?

예를 들어 N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우를 생각해 봅시다.

- 두 도시 A, B를 선택했을 때 A에서 B로 이동하는 경로가 반드시 존재하도록 도로를 설치합니다.

# 크루스칼 알고리즘

- 대표적인 최소 신장 트리 알고리즘입니다.
    
- 그리디 알고리즘으로 분류됩니다.
    
- 구체적인 동작 과정은 다음과 같습니다.
    
    1. 간선 데이터를 비용에 따라 **오름차순으로 정렬**합니다.
    2. 간선을 하나씩 확인하며 **현재의 간선이 사이클을 발생시키는지 확인**합니다.
        1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킵니다.
        2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않습니다.
    3. 모든 간선에 대하야 2번의 과정을 반복합니다.

- [초기 단계] 그래프의 모든 간선 정보에 대하여 **오름차순 정렬을 수행합니다.**

- [Step 1] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (3, 4)를 선택하여 처리합니다.

- [Step 2] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (4, 7)을 선택하여 처리합니다.

- [Step 3] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (4, 6)을 선택하여 처리합니다.

- [Step 4] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (6, 7)을 선택하여 처리합니다.

- [Step 5] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (1, 2)을 선택하여 처리합니다.

- [Step 6] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (2, 6)을 선택하여 처리합니다.

- [Step 7] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (2, 3)을 선택하여 처리합니다.

- [Step 8] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (5, 6)을 선택하여 처리합니다.

- [Step 9] 아직 처리하지 않은 간선 중에서 가장 짧은 간선인 (1, 5)을 선택하여 처리합니다.

- [알고리즘 수행 결과] 최소 신장 트리에 포함되어 있는 간선의 비용만 모두 더하면, 그 값이 최종 비용에 해당합니다.

```python
#  특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀 호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1)  # 부모 테이블 초기화하기

# 모든 간선을 담을 리스트와, 최종 비용을 담을 변수
edges = []
result = 0

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# 모든 간선에 대한 정보를 입력 받기
for _ in range(e):
    a, b, cost = map(int, input().split())
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost, a, b))

# 간선을 비용순으로 정렬
edges.sort()

# 간선을 하나씩 확인하며
for edge in edges:
    cost, a, b = edge
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost

print(result)
```

```python
# 출력
7 9
1 2 29
1 5 75
2 3 35
2 6 34
3 4 7
4 6 23
4 7 13
5 6 53
6 7 25

# 결과
159
```

## 크루스칼 알고리즘 성능 분석

- 크루스칼 알고리즘은 간선의 개수가 E개일 때, 0(Elog E)의 시간 복잡도를 가집니다.
- 크루스칼 알고르즘에서 가장 많은 시간을 요구하는 곳은 간선을 정렬을 수행하는 부분입니다.
    - 표준 라이브러리를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도는 O(ElogE) 입니다.

# 위상 정렬

**사이클이 없는 방향 그래프**의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열**하는 것을 의미합니다.

- 예시) 선수과목을 고려한 학습 순서 설정
    
    위 세 과목을 모두 듣기 위한 적절한 학습 순서는?
    
    - 자료 구조 → 알고리즘 → 고급 알고리즘(⭕)
    - 자료구조 → 고급 알고리즘 → 알고리즘(❌)

# 진입차수와 진출차수

- 진입차수(Indegree): 특정한 노드로 들어오는 간선의 개수
- 진출차수(Outdegree): 특정한 노드에서 나가는 간선의 개수


큐를 이용하는 위상 정렬 알고리즘의 동작 과정은 다음과 같습니다.

1. 진입차수가 0인 모든 노드를 큐에 넣는다
2. 큐가 빌 때까지 다음의 과정을 반복한다.
    1. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다.
    2. 새롭게 진입차수가 0인 된 노드를 큐에 넣는다.

결과적으로 **각 노드가 큐에 들어온 순서가 위상 정렬을 수행한 결과**와 같습니다.

위상 정렬을 수행할 그래프를 준비합니다.

- 이때 그래프는 **사이클이 없는 방향 그래프(DAG)**여야 합니다.

- [초기 단계] 초기 단계에서는 진입차수가 0인 모든 노드를 큐에 넣습니다.
    - 처음에 **노드** 1이 큐에 삽입됩니다.

- [Step 1] 큐에서 **노드 1**을 꺼낸 뒤에 **노드 1**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드**들을 큐에 삽입합니다.

- [Step 2] 큐에서 **노드 2**을 꺼낸 뒤에 **노드 2**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드**들을 큐에 삽입합니다.

- [Step 3] 큐에서 **노드 5**을 꺼낸 뒤에 **노드 5**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드**들을 큐에 삽입합니다.

- [Step 4] 큐에서 **노드 3**을 꺼낸 뒤에 **노드 3**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드가 없으므로 그냥 넘어갑니다.**

- [Step 5] 큐에서 **노드 6**을 꺼낸 뒤에 **노드 6**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드를 큐에 삽입합니다.**

- [Step 6] 큐에서 **노드 4**을 꺼낸 뒤에 **노드 4**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드를 큐에 삽입합니다.**

- [Step 7] 큐에서 **노드 7**을 꺼낸 뒤에 **노드 7**에서 나가는 간선을 제거합니다.
    - 새롭게 **진입차수가 0인 된 노드가 없으므로 그냥 넘어갑니다.**

- [위상 정렬 결과]
    - 큐에 삽입된 전체 노드 순서: 1 → 2 → 5 → 3 → 6 → 4 → 7

## 위상 정렬의 특징

- 위상 정렬은 DAG에 대해서만 수행할 수 있습니다.
    - DAG(Direct Acyclic Graph): 순환하지 않는 방향 그래프
- 위상 정렬에서는 **여러 가지 답이 존재**할 수 있습니다.
    - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면 여러 가지 답이 존재합니다.
- **모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단**할 수 있습니다.
    - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못합니다.
- 스택을 활용한 DFS를 이용해 위상 정렬을 수행할 수도 있습니다.

```python
from collections import deque

# 노드의 개수와 간선의 개수를 입력 받기
v, e = map(int, input().split())
# 모든 노드에 대한 진입차수는 0으로 초기화
indefree = [0] * (v + 1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트 초기화
graph = [[] for i in range(v + 1)]

# 방향 그래프의 모든 간선 정보를 입력 받기
for _ in range(e):
    a, b = map(int, input().split())
    graph[a].append(b)  # 정점 A에서 B로 이동 가능
    # 진입 차수를 1 증가
    indefree[b] += 1

# 위상 정렬 함수
def topology_sort():
    result = []  # 알고리즘 수행 결과를 담을 리스트
    q = deque()  # 큐 기능을 위한 deque 라이브러리 사용
    # 처음 시작할 때는 진입차수가 0인 노드를 큐에 삽입
    for i in range(1, v + 1):
        if indefree[i] == 0:
            q.append(i)
    # 큐가 빌 때까지 반복
    while q:
        # 큐에서 원소 꺼내기
        now = q.popleft()
        result.append(now)
        # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
        for i in graph[now]:
            indefree[i] -= 1
            # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
            if indefree[i] == 0:
                q.append(i)
    # 위상 정렬을 수행한 결과 출력
    for i in result:
        print(i, end=' ')

topology_sort()
```

```python
# 출력
7 8
1 2
1 5
2 3
2 6
3 4
4 7
5 6
6 4

# 결과
1 2 5 3 6 4 7 
```

## 위상 정렬 알고리즘 성능 분석

위상 정렬을 위해 차례대로 모든 노드를 확인하며 각 노드에서 나가는 간선을 차례대로 제거해야 합니다.

- 위상 정렬 알고리즘의 시간 복잡도는 O(V + E)입니다.